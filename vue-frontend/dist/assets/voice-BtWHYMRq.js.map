{"version":3,"file":"voice-BtWHYMRq.js","sources":["../../node_modules/.pnpm/lucide-vue-next@0.511.0_vue@3.5.14_typescript@5.8.3_/node_modules/lucide-vue-next/dist/esm/icons/volume-x.js","../../src/stores/voice.ts"],"sourcesContent":["/**\n * @license lucide-vue-next v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst VolumeX = createLucideIcon(\"volume-x\", [\n  [\n    \"path\",\n    {\n      d: \"M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z\",\n      key: \"uqj9uw\"\n    }\n  ],\n  [\"line\", { x1: \"22\", x2: \"16\", y1: \"9\", y2: \"15\", key: \"1ewh16\" }],\n  [\"line\", { x1: \"16\", x2: \"22\", y1: \"9\", y2: \"15\", key: \"5ykzw1\" }]\n]);\n\nexport { VolumeX as default };\n//# sourceMappingURL=volume-x.js.map\n","import { defineStore } from 'pinia'\nimport { ref, computed } from 'vue'\nimport type { VoiceMessage, CallState } from '@/types'\nimport { generateId, cleanTextForSpeech } from '@/utils'\nimport { \n  sendVoiceMessage, \n  synthesizeSpeech, \n  checkFunAudioStatus, \n  clearConversationHistory \n} from '@/utils/api'\n\nexport const useVoiceStore = defineStore('voice', () => {\n  // 状态\n  const messages = ref<VoiceMessage[]>([])\n  const callState = ref<CallState>('idle')\n  const isRecording = ref(false)\n  const isAIPlaying = ref(false)\n  const isMuted = ref(false)\n  const sessionId = ref(`voice-chat-${Date.now()}`)\n  const conversationRounds = ref(0)\n  const currentTranscript = ref('')\n  const funAudioAvailable = ref(false)\n  const speechRecognitionAvailable = ref(false)\n\n  // 音频相关引用\n  const audioStream = ref<MediaStream | null>(null)\n  const audioContext = ref<AudioContext | null>(null)\n  const currentAudio = ref<HTMLAudioElement | null>(null)\n  const analyserNode = ref<AnalyserNode | null>(null)\n  const mediaRecorder = ref<MediaRecorder | null>(null)\n  \n  // 智能静音检测配置\n  const silenceThreshold = ref(30) // 静音阈值 (0-255)\n  const silenceTimeout = ref(2000) // 静音超时时间 (毫秒)\n  const minRecordingTime = ref(1000) // 最小录音时间 (毫秒)\n  const maxRecordingTime = ref(30000) // 最大录音时间 (毫秒)\n  \n  // 静音检测状态\n  const lastSoundTime = ref(0)\n  const recordingStartTime = ref(0)\n  const silenceDetectionActive = ref(false)\n\n  // 计算属性\n  const hasMessages = computed(() => messages.value.length > 0)\n  const isConnected = computed(() => callState.value !== 'idle')\n  const canStartCall = computed(() => funAudioAvailable.value && callState.value === 'idle')\n\n  // 添加消息\n  function addMessage(message: Omit<VoiceMessage, 'id' | 'timestamp'>) {\n    const newMessage: VoiceMessage = {\n      ...message,\n      id: generateId(),\n      timestamp: new Date()\n    }\n    messages.value.push(newMessage)\n    return newMessage\n  }\n\n  // 音频监测函数\n  function startAudioMonitoring(): void {\n    if (!audioContext.value || !analyserNode.value) return\n\n    const bufferLength = analyserNode.value.frequencyBinCount\n    const dataArray = new Uint8Array(bufferLength)\n    \n    silenceDetectionActive.value = true\n    lastSoundTime.value = Date.now()\n    recordingStartTime.value = Date.now()\n\n    function checkAudioLevel(): void {\n      if (!silenceDetectionActive.value || !analyserNode.value) return\n\n      analyserNode.value.getByteFrequencyData(dataArray)\n      \n      // 计算平均音量\n      let sum = 0\n      for (let i = 0; i < bufferLength; i++) {\n        sum += dataArray[i]\n      }\n      const averageVolume = sum / bufferLength\n\n      const currentTime = Date.now()\n      const recordingDuration = currentTime - recordingStartTime.value\n      const silenceDuration = currentTime - lastSoundTime.value\n\n      // 如果检测到声音，更新最后声音时间\n      if (averageVolume > silenceThreshold.value) {\n        lastSoundTime.value = currentTime\n      }\n\n      // 检查是否应该停止录音\n      const shouldStop = (\n        // 静音时间超过阈值且已录音最小时间\n        (silenceDuration > silenceTimeout.value && recordingDuration > minRecordingTime.value) ||\n        // 录音时间超过最大时间\n        recordingDuration > maxRecordingTime.value\n      )\n\n      if (shouldStop) {\n        console.log(`🔇 智能静音检测: 平均音量=${averageVolume.toFixed(1)}, 静音时长=${silenceDuration}ms, 录音时长=${recordingDuration}ms`)\n        stopRecording()\n        return\n      }\n\n      // 继续监测\n      requestAnimationFrame(checkAudioLevel)\n    }\n\n    checkAudioLevel()\n  }\n\n  // 停止音频监测\n  function stopAudioMonitoring(): void {\n    silenceDetectionActive.value = false\n  }\n\n  // 停止录音\n  function stopRecording(): void {\n    if (mediaRecorder.value && mediaRecorder.value.state === 'recording') {\n      mediaRecorder.value.stop()\n      isRecording.value = false\n      stopAudioMonitoring()\n      console.log('🎤 录音已停止')\n    }\n  }\n\n  // 检查服务状态\n  async function checkServiceStatus() {\n    try {\n      funAudioAvailable.value = await checkFunAudioStatus()\n      \n      // 检查Web Speech API支持\n      speechRecognitionAvailable.value = !!(\n        (window as any).webkitSpeechRecognition || (window as any).SpeechRecognition\n      )\n      \n      console.log('服务状态检查:', {\n        funAudio: funAudioAvailable.value,\n        speechRecognition: speechRecognitionAvailable.value\n      })\n    } catch (error) {\n      console.error('检查服务状态失败:', error)\n      funAudioAvailable.value = false\n    }\n  }\n\n  // 初始化录音\n  async function initRecording(): Promise<void> {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ \n        audio: {\n          echoCancellation: true,\n          noiseSuppression: true,\n          autoGainControl: true\n        } \n      })\n      \n      audioStream.value = stream\n      audioContext.value = new AudioContext()\n      \n      // 创建音频分析器用于智能静音检测\n      const source = audioContext.value.createMediaStreamSource(stream)\n      analyserNode.value = audioContext.value.createAnalyser()\n      analyserNode.value.fftSize = 256\n      analyserNode.value.smoothingTimeConstant = 0.8\n      source.connect(analyserNode.value)\n      \n      console.log('✅ 录音初始化成功，智能静音检测已启用')\n    } catch (error) {\n      console.error('❌ 录音初始化失败:', error)\n      throw new Error('无法访问麦克风，请检查权限设置')\n    }\n  }\n\n  // 开始录音\n  async function startRecording(): Promise<void> {\n    if (!audioStream.value) {\n      await initRecording()\n    }\n\n    if (!audioStream.value) {\n      throw new Error('音频流未初始化')\n    }\n\n    try {\n      mediaRecorder.value = new MediaRecorder(audioStream.value, {\n        mimeType: 'audio/webm;codecs=opus'\n      })\n\n      const audioChunks: Blob[] = []\n      \n      mediaRecorder.value.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          audioChunks.push(event.data)\n        }\n      }\n\n      mediaRecorder.value.onstop = async () => {\n        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' })\n        await handleUserSpeech('', audioBlob)\n      }\n\n      mediaRecorder.value.start()\n      isRecording.value = true\n      callState.value = 'listening'\n      \n      // 启动智能静音检测\n      startAudioMonitoring()\n\n      console.log('🎤 开始录音 (智能静音检测已启用)')\n    } catch (error) {\n      console.error('❌ 开始录音失败:', error)\n      throw error\n    }\n  }\n\n  // 处理用户语音\n  async function handleUserSpeech(transcript: string, audioBlob?: Blob): Promise<void> {\n    if (!transcript.trim() && !audioBlob) return\n\n    callState.value = 'processing'\n    let userMessage: VoiceMessage | null = null\n    let aiResponse = ''\n\n    try {\n      if (funAudioAvailable.value && audioBlob) {\n        console.log('🎯 使用FunAudioLLM流程')\n\n        const result = await sendVoiceMessage(audioBlob, sessionId.value, 'auto')\n\n        if (result.success) {\n          userMessage = addMessage({\n            content: result.recognized_text || '[语音输入]',\n            isUser: true,\n            recognizedText: result.recognized_text\n          })\n\n          aiResponse = result.response\n          conversationRounds.value = result.history_length || 0\n\n          console.log('✅ FunAudioLLM语音对话成功')\n        } else {\n          const errorMsg = result.error || ''\n          if (errorMsg.includes('未识别到有效语音内容')) {\n            console.log('🔇 未检测到语音内容，自动结束通话')\n            endCall()\n            return\n          } else {\n            throw new Error(result.error || 'FunAudioLLM对话失败')\n          }\n        }\n      } else {\n        throw new Error('无有效输入')\n      }\n\n      if (aiResponse) {\n        const aiMessage = addMessage({\n          content: aiResponse,\n          isUser: false\n        })\n\n        await speakText(aiResponse)\n      }\n    } catch (error: any) {\n      console.error('❌ 处理语音失败:', error)\n\n      if (!userMessage) {\n        userMessage = addMessage({\n          content: transcript || '[语音输入]',\n          isUser: true\n        })\n      }\n\n      addMessage({\n        content: '抱歉，处理您的语音时出现了问题。请稍后重试。',\n        isUser: false\n      })\n    }\n\n    callState.value = 'connected'\n  }\n\n  // 文本转语音\n  async function speakText(text: string): Promise<void> {\n    try {\n      const cleanedText = cleanTextForSpeech(text)\n\n      console.log('🔊 开始语音合成:', cleanedText.substring(0, 50) + '...')\n\n      if (!cleanedText.trim()) {\n        console.warn('⚠️ 清理后的文本为空，跳过语音合成')\n        isAIPlaying.value = false\n        callState.value = 'connected'\n        return\n      }\n\n      isAIPlaying.value = true\n      callState.value = 'speaking'\n\n      try {\n        const audioBuffer = await synthesizeSpeech({\n          text: cleanedText,\n          voice: 'zh-CN-XiaoxiaoNeural',\n          rate: 0.9,\n          pitch: 1.1\n        })\n\n        const audioBlob = new Blob([audioBuffer], { type: 'audio/wav' })\n        const audioUrl = URL.createObjectURL(audioBlob)\n\n        const audio = new Audio(audioUrl)\n        audio.volume = isMuted.value ? 0 : 0.8\n        currentAudio.value = audio\n\n        audio.onplay = () => {\n          console.log('✅ AI语音播放开始')\n        }\n\n        audio.onended = () => {\n          console.log('✅ AI语音播放结束')\n          isAIPlaying.value = false\n          callState.value = 'connected'\n          URL.revokeObjectURL(audioUrl)\n\n          // 播放结束后继续录音\n          setTimeout(() => {\n            if (funAudioAvailable.value && callState.value === 'connected') {\n              startRecording()\n            }\n          }, 500)\n        }\n\n        audio.onerror = (event) => {\n          console.error('❌ 音频播放错误:', event)\n          isAIPlaying.value = false\n          callState.value = 'connected'\n          URL.revokeObjectURL(audioUrl)\n        }\n\n        await audio.play()\n      } catch (error) {\n        console.error('❌ TTS API调用失败:', error)\n        isAIPlaying.value = false\n        callState.value = 'connected'\n      }\n    } catch (error) {\n      console.error('❌ 语音合成失败:', error)\n      isAIPlaying.value = false\n      callState.value = 'connected'\n    }\n  }\n\n  // 开始通话\n  async function startCall(): Promise<void> {\n    if (!funAudioAvailable.value) {\n      console.log('⚠️ 检测到FunAudioLLM服务不可用，尝试重新检查状态...')\n      await checkServiceStatus()\n      await new Promise(resolve => setTimeout(resolve, 1000))\n    }\n\n    try {\n      callState.value = 'connecting'\n      console.log('🎤 启动FunAudioLLM录音模式')\n      await initRecording()\n      callState.value = 'connected'\n\n      setTimeout(() => {\n        startRecording()\n      }, 1000)\n\n      messages.value = []\n    } catch (error: any) {\n      console.error('❌ 开始通话失败:', error)\n      callState.value = 'idle'\n      throw new Error('开始通话失败，请检查麦克风权限并重试')\n    }\n  }\n\n  // 结束通话\n  function endCall(): void {\n    callState.value = 'idle'\n    isRecording.value = false\n    isAIPlaying.value = false\n    currentTranscript.value = ''\n\n    // 停止智能静音检测\n    stopAudioMonitoring()\n\n    // 停止录音\n    if (mediaRecorder.value && mediaRecorder.value.state === 'recording') {\n      mediaRecorder.value.stop()\n    }\n    mediaRecorder.value = null\n\n    // 停止音频流\n    if (audioStream.value) {\n      audioStream.value.getTracks().forEach(track => track.stop())\n      audioStream.value = null\n    }\n\n    // 关闭音频上下文\n    if (audioContext.value) {\n      audioContext.value.close()\n      audioContext.value = null\n    }\n    analyserNode.value = null\n\n    // 停止当前播放的音频\n    if (currentAudio.value) {\n      currentAudio.value.pause()\n      currentAudio.value = null\n    }\n\n    console.log('📞 通话已结束，所有资源已清理')\n  }\n\n  // 切换静音\n  function toggleMute(): void {\n    isMuted.value = !isMuted.value\n    if (currentAudio.value) {\n      currentAudio.value.pause()\n      isAIPlaying.value = false\n    }\n  }\n\n  // 中断AI说话\n  function interruptAI(): void {\n    if (isAIPlaying.value) {\n      if (currentAudio.value) {\n        currentAudio.value.pause()\n      }\n      isAIPlaying.value = false\n      callState.value = 'connected'\n\n      if (funAudioAvailable.value) {\n        setTimeout(() => {\n          startRecording()\n        }, 500)\n      }\n    }\n  }\n\n  // 清除对话历史\n  async function clearHistory(): Promise<void> {\n    try {\n      const success = await clearConversationHistory(sessionId.value)\n      if (success) {\n        messages.value = []\n        conversationRounds.value = 0\n        console.log('✅ 对话历史已清除')\n      } else {\n        console.error('❌ 清除对话历史失败')\n      }\n    } catch (error) {\n      console.error('❌ 清除对话历史错误:', error)\n    }\n  }\n\n  // 重新开始会话\n  function restartSession(): void {\n    sessionId.value = `voice-chat-${Date.now()}`\n    messages.value = []\n    conversationRounds.value = 0\n    console.log('🔄 会话已重新开始')\n  }\n\n  // 获取状态显示文本\n  function getStatusText(): string {\n    switch (callState.value) {\n      case 'idle':\n        return '未连接'\n      case 'connecting':\n        return '正在连接...'\n      case 'connected':\n        return '已连接'\n      case 'listening':\n        return '正在听您说话...'\n      case 'speaking':\n        return 'AI正在回复...'\n      case 'processing':\n        return '正在处理...'\n      default:\n        return '未知状态'\n    }\n  }\n\n  // 配置智能静音检测参数\n  function configureSilenceDetection(config: {\n    threshold?: number\n    timeout?: number\n    minRecordingTime?: number\n    maxRecordingTime?: number\n  }): void {\n    if (config.threshold !== undefined) {\n      silenceThreshold.value = Math.max(0, Math.min(255, config.threshold))\n    }\n    if (config.timeout !== undefined) {\n      silenceTimeout.value = Math.max(500, config.timeout)\n    }\n    if (config.minRecordingTime !== undefined) {\n      minRecordingTime.value = Math.max(500, config.minRecordingTime)\n    }\n    if (config.maxRecordingTime !== undefined) {\n      maxRecordingTime.value = Math.max(5000, config.maxRecordingTime)\n    }\n    \n    console.log('🔧 智能静音检测配置已更新:', {\n      threshold: silenceThreshold.value,\n      timeout: silenceTimeout.value,\n      minRecordingTime: minRecordingTime.value,\n      maxRecordingTime: maxRecordingTime.value\n    })\n  }\n\n  return {\n    // 状态\n    messages,\n    callState,\n    isRecording,\n    isAIPlaying,\n    isMuted,\n    sessionId,\n    conversationRounds,\n    currentTranscript,\n    funAudioAvailable,\n    speechRecognitionAvailable,\n    silenceDetectionActive,\n    \n    // 智能静音检测配置\n    silenceThreshold,\n    silenceTimeout,\n    minRecordingTime,\n    maxRecordingTime,\n    \n    // 计算属性\n    hasMessages,\n    isConnected,\n    canStartCall,\n    \n    // 方法\n    addMessage,\n    checkServiceStatus,\n    startCall,\n    endCall,\n    startRecording,\n    stopRecording,\n    toggleMute,\n    interruptAI,\n    clearHistory,\n    restartSession,\n    getStatusText,\n    configureSilenceDetection\n  }\n}) "],"names":["VolumeX","createLucideIcon","useVoiceStore","defineStore","messages","ref","callState","isRecording","isAIPlaying","isMuted","sessionId","conversationRounds","currentTranscript","funAudioAvailable","speechRecognitionAvailable","audioStream","audioContext","currentAudio","analyserNode","mediaRecorder","silenceThreshold","silenceTimeout","minRecordingTime","maxRecordingTime","lastSoundTime","recordingStartTime","silenceDetectionActive","hasMessages","computed","isConnected","canStartCall","addMessage","message","newMessage","generateId","startAudioMonitoring","bufferLength","dataArray","checkAudioLevel","sum","i","averageVolume","currentTime","recordingDuration","silenceDuration","stopRecording","stopAudioMonitoring","checkServiceStatus","checkFunAudioStatus","error","initRecording","stream","source","startRecording","audioChunks","event","audioBlob","handleUserSpeech","transcript","userMessage","aiResponse","result","sendVoiceMessage","endCall","aiMessage","speakText","text","cleanedText","cleanTextForSpeech","audioBuffer","synthesizeSpeech","audioUrl","audio","startCall","resolve","track","toggleMute","interruptAI","clearHistory","clearConversationHistory","restartSession","getStatusText","configureSilenceDetection","config"],"mappings":"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","x_google_ignoreList":[0]}