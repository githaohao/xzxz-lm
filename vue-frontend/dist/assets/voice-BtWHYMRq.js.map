{"version":3,"file":"voice-BtWHYMRq.js","sources":["../../node_modules/.pnpm/lucide-vue-next@0.511.0_vue@3.5.14_typescript@5.8.3_/node_modules/lucide-vue-next/dist/esm/icons/volume-x.js","../../src/stores/voice.ts"],"sourcesContent":["/**\n * @license lucide-vue-next v0.511.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst VolumeX = createLucideIcon(\"volume-x\", [\n  [\n    \"path\",\n    {\n      d: \"M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z\",\n      key: \"uqj9uw\"\n    }\n  ],\n  [\"line\", { x1: \"22\", x2: \"16\", y1: \"9\", y2: \"15\", key: \"1ewh16\" }],\n  [\"line\", { x1: \"16\", x2: \"22\", y1: \"9\", y2: \"15\", key: \"5ykzw1\" }]\n]);\n\nexport { VolumeX as default };\n//# sourceMappingURL=volume-x.js.map\n","import { defineStore } from 'pinia'\nimport { ref, computed } from 'vue'\nimport type { VoiceMessage, CallState } from '@/types'\nimport { generateId, cleanTextForSpeech } from '@/utils'\nimport { \n  sendVoiceMessage, \n  synthesizeSpeech, \n  checkFunAudioStatus, \n  clearConversationHistory \n} from '@/utils/api'\n\nexport const useVoiceStore = defineStore('voice', () => {\n  // çŠ¶æ€\n  const messages = ref<VoiceMessage[]>([])\n  const callState = ref<CallState>('idle')\n  const isRecording = ref(false)\n  const isAIPlaying = ref(false)\n  const isMuted = ref(false)\n  const sessionId = ref(`voice-chat-${Date.now()}`)\n  const conversationRounds = ref(0)\n  const currentTranscript = ref('')\n  const funAudioAvailable = ref(false)\n  const speechRecognitionAvailable = ref(false)\n\n  // éŸ³é¢‘ç›¸å…³å¼•ç”¨\n  const audioStream = ref<MediaStream | null>(null)\n  const audioContext = ref<AudioContext | null>(null)\n  const currentAudio = ref<HTMLAudioElement | null>(null)\n  const analyserNode = ref<AnalyserNode | null>(null)\n  const mediaRecorder = ref<MediaRecorder | null>(null)\n  \n  // æ™ºèƒ½é™éŸ³æ£€æµ‹é…ç½®\n  const silenceThreshold = ref(30) // é™éŸ³é˜ˆå€¼ (0-255)\n  const silenceTimeout = ref(2000) // é™éŸ³è¶…æ—¶æ—¶é—´ (æ¯«ç§’)\n  const minRecordingTime = ref(1000) // æœ€å°å½•éŸ³æ—¶é—´ (æ¯«ç§’)\n  const maxRecordingTime = ref(30000) // æœ€å¤§å½•éŸ³æ—¶é—´ (æ¯«ç§’)\n  \n  // é™éŸ³æ£€æµ‹çŠ¶æ€\n  const lastSoundTime = ref(0)\n  const recordingStartTime = ref(0)\n  const silenceDetectionActive = ref(false)\n\n  // è®¡ç®—å±æ€§\n  const hasMessages = computed(() => messages.value.length > 0)\n  const isConnected = computed(() => callState.value !== 'idle')\n  const canStartCall = computed(() => funAudioAvailable.value && callState.value === 'idle')\n\n  // æ·»åŠ æ¶ˆæ¯\n  function addMessage(message: Omit<VoiceMessage, 'id' | 'timestamp'>) {\n    const newMessage: VoiceMessage = {\n      ...message,\n      id: generateId(),\n      timestamp: new Date()\n    }\n    messages.value.push(newMessage)\n    return newMessage\n  }\n\n  // éŸ³é¢‘ç›‘æµ‹å‡½æ•°\n  function startAudioMonitoring(): void {\n    if (!audioContext.value || !analyserNode.value) return\n\n    const bufferLength = analyserNode.value.frequencyBinCount\n    const dataArray = new Uint8Array(bufferLength)\n    \n    silenceDetectionActive.value = true\n    lastSoundTime.value = Date.now()\n    recordingStartTime.value = Date.now()\n\n    function checkAudioLevel(): void {\n      if (!silenceDetectionActive.value || !analyserNode.value) return\n\n      analyserNode.value.getByteFrequencyData(dataArray)\n      \n      // è®¡ç®—å¹³å‡éŸ³é‡\n      let sum = 0\n      for (let i = 0; i < bufferLength; i++) {\n        sum += dataArray[i]\n      }\n      const averageVolume = sum / bufferLength\n\n      const currentTime = Date.now()\n      const recordingDuration = currentTime - recordingStartTime.value\n      const silenceDuration = currentTime - lastSoundTime.value\n\n      // å¦‚æœæ£€æµ‹åˆ°å£°éŸ³ï¼Œæ›´æ–°æœ€åå£°éŸ³æ—¶é—´\n      if (averageVolume > silenceThreshold.value) {\n        lastSoundTime.value = currentTime\n      }\n\n      // æ£€æŸ¥æ˜¯å¦åº”è¯¥åœæ­¢å½•éŸ³\n      const shouldStop = (\n        // é™éŸ³æ—¶é—´è¶…è¿‡é˜ˆå€¼ä¸”å·²å½•éŸ³æœ€å°æ—¶é—´\n        (silenceDuration > silenceTimeout.value && recordingDuration > minRecordingTime.value) ||\n        // å½•éŸ³æ—¶é—´è¶…è¿‡æœ€å¤§æ—¶é—´\n        recordingDuration > maxRecordingTime.value\n      )\n\n      if (shouldStop) {\n        console.log(`ğŸ”‡ æ™ºèƒ½é™éŸ³æ£€æµ‹: å¹³å‡éŸ³é‡=${averageVolume.toFixed(1)}, é™éŸ³æ—¶é•¿=${silenceDuration}ms, å½•éŸ³æ—¶é•¿=${recordingDuration}ms`)\n        stopRecording()\n        return\n      }\n\n      // ç»§ç»­ç›‘æµ‹\n      requestAnimationFrame(checkAudioLevel)\n    }\n\n    checkAudioLevel()\n  }\n\n  // åœæ­¢éŸ³é¢‘ç›‘æµ‹\n  function stopAudioMonitoring(): void {\n    silenceDetectionActive.value = false\n  }\n\n  // åœæ­¢å½•éŸ³\n  function stopRecording(): void {\n    if (mediaRecorder.value && mediaRecorder.value.state === 'recording') {\n      mediaRecorder.value.stop()\n      isRecording.value = false\n      stopAudioMonitoring()\n      console.log('ğŸ¤ å½•éŸ³å·²åœæ­¢')\n    }\n  }\n\n  // æ£€æŸ¥æœåŠ¡çŠ¶æ€\n  async function checkServiceStatus() {\n    try {\n      funAudioAvailable.value = await checkFunAudioStatus()\n      \n      // æ£€æŸ¥Web Speech APIæ”¯æŒ\n      speechRecognitionAvailable.value = !!(\n        (window as any).webkitSpeechRecognition || (window as any).SpeechRecognition\n      )\n      \n      console.log('æœåŠ¡çŠ¶æ€æ£€æŸ¥:', {\n        funAudio: funAudioAvailable.value,\n        speechRecognition: speechRecognitionAvailable.value\n      })\n    } catch (error) {\n      console.error('æ£€æŸ¥æœåŠ¡çŠ¶æ€å¤±è´¥:', error)\n      funAudioAvailable.value = false\n    }\n  }\n\n  // åˆå§‹åŒ–å½•éŸ³\n  async function initRecording(): Promise<void> {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ \n        audio: {\n          echoCancellation: true,\n          noiseSuppression: true,\n          autoGainControl: true\n        } \n      })\n      \n      audioStream.value = stream\n      audioContext.value = new AudioContext()\n      \n      // åˆ›å»ºéŸ³é¢‘åˆ†æå™¨ç”¨äºæ™ºèƒ½é™éŸ³æ£€æµ‹\n      const source = audioContext.value.createMediaStreamSource(stream)\n      analyserNode.value = audioContext.value.createAnalyser()\n      analyserNode.value.fftSize = 256\n      analyserNode.value.smoothingTimeConstant = 0.8\n      source.connect(analyserNode.value)\n      \n      console.log('âœ… å½•éŸ³åˆå§‹åŒ–æˆåŠŸï¼Œæ™ºèƒ½é™éŸ³æ£€æµ‹å·²å¯ç”¨')\n    } catch (error) {\n      console.error('âŒ å½•éŸ³åˆå§‹åŒ–å¤±è´¥:', error)\n      throw new Error('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®')\n    }\n  }\n\n  // å¼€å§‹å½•éŸ³\n  async function startRecording(): Promise<void> {\n    if (!audioStream.value) {\n      await initRecording()\n    }\n\n    if (!audioStream.value) {\n      throw new Error('éŸ³é¢‘æµæœªåˆå§‹åŒ–')\n    }\n\n    try {\n      mediaRecorder.value = new MediaRecorder(audioStream.value, {\n        mimeType: 'audio/webm;codecs=opus'\n      })\n\n      const audioChunks: Blob[] = []\n      \n      mediaRecorder.value.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          audioChunks.push(event.data)\n        }\n      }\n\n      mediaRecorder.value.onstop = async () => {\n        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' })\n        await handleUserSpeech('', audioBlob)\n      }\n\n      mediaRecorder.value.start()\n      isRecording.value = true\n      callState.value = 'listening'\n      \n      // å¯åŠ¨æ™ºèƒ½é™éŸ³æ£€æµ‹\n      startAudioMonitoring()\n\n      console.log('ğŸ¤ å¼€å§‹å½•éŸ³ (æ™ºèƒ½é™éŸ³æ£€æµ‹å·²å¯ç”¨)')\n    } catch (error) {\n      console.error('âŒ å¼€å§‹å½•éŸ³å¤±è´¥:', error)\n      throw error\n    }\n  }\n\n  // å¤„ç†ç”¨æˆ·è¯­éŸ³\n  async function handleUserSpeech(transcript: string, audioBlob?: Blob): Promise<void> {\n    if (!transcript.trim() && !audioBlob) return\n\n    callState.value = 'processing'\n    let userMessage: VoiceMessage | null = null\n    let aiResponse = ''\n\n    try {\n      if (funAudioAvailable.value && audioBlob) {\n        console.log('ğŸ¯ ä½¿ç”¨FunAudioLLMæµç¨‹')\n\n        const result = await sendVoiceMessage(audioBlob, sessionId.value, 'auto')\n\n        if (result.success) {\n          userMessage = addMessage({\n            content: result.recognized_text || '[è¯­éŸ³è¾“å…¥]',\n            isUser: true,\n            recognizedText: result.recognized_text\n          })\n\n          aiResponse = result.response\n          conversationRounds.value = result.history_length || 0\n\n          console.log('âœ… FunAudioLLMè¯­éŸ³å¯¹è¯æˆåŠŸ')\n        } else {\n          const errorMsg = result.error || ''\n          if (errorMsg.includes('æœªè¯†åˆ«åˆ°æœ‰æ•ˆè¯­éŸ³å†…å®¹')) {\n            console.log('ğŸ”‡ æœªæ£€æµ‹åˆ°è¯­éŸ³å†…å®¹ï¼Œè‡ªåŠ¨ç»“æŸé€šè¯')\n            endCall()\n            return\n          } else {\n            throw new Error(result.error || 'FunAudioLLMå¯¹è¯å¤±è´¥')\n          }\n        }\n      } else {\n        throw new Error('æ— æœ‰æ•ˆè¾“å…¥')\n      }\n\n      if (aiResponse) {\n        const aiMessage = addMessage({\n          content: aiResponse,\n          isUser: false\n        })\n\n        await speakText(aiResponse)\n      }\n    } catch (error: any) {\n      console.error('âŒ å¤„ç†è¯­éŸ³å¤±è´¥:', error)\n\n      if (!userMessage) {\n        userMessage = addMessage({\n          content: transcript || '[è¯­éŸ³è¾“å…¥]',\n          isUser: true\n        })\n      }\n\n      addMessage({\n        content: 'æŠ±æ­‰ï¼Œå¤„ç†æ‚¨çš„è¯­éŸ³æ—¶å‡ºç°äº†é—®é¢˜ã€‚è¯·ç¨åé‡è¯•ã€‚',\n        isUser: false\n      })\n    }\n\n    callState.value = 'connected'\n  }\n\n  // æ–‡æœ¬è½¬è¯­éŸ³\n  async function speakText(text: string): Promise<void> {\n    try {\n      const cleanedText = cleanTextForSpeech(text)\n\n      console.log('ğŸ”Š å¼€å§‹è¯­éŸ³åˆæˆ:', cleanedText.substring(0, 50) + '...')\n\n      if (!cleanedText.trim()) {\n        console.warn('âš ï¸ æ¸…ç†åçš„æ–‡æœ¬ä¸ºç©ºï¼Œè·³è¿‡è¯­éŸ³åˆæˆ')\n        isAIPlaying.value = false\n        callState.value = 'connected'\n        return\n      }\n\n      isAIPlaying.value = true\n      callState.value = 'speaking'\n\n      try {\n        const audioBuffer = await synthesizeSpeech({\n          text: cleanedText,\n          voice: 'zh-CN-XiaoxiaoNeural',\n          rate: 0.9,\n          pitch: 1.1\n        })\n\n        const audioBlob = new Blob([audioBuffer], { type: 'audio/wav' })\n        const audioUrl = URL.createObjectURL(audioBlob)\n\n        const audio = new Audio(audioUrl)\n        audio.volume = isMuted.value ? 0 : 0.8\n        currentAudio.value = audio\n\n        audio.onplay = () => {\n          console.log('âœ… AIè¯­éŸ³æ’­æ”¾å¼€å§‹')\n        }\n\n        audio.onended = () => {\n          console.log('âœ… AIè¯­éŸ³æ’­æ”¾ç»“æŸ')\n          isAIPlaying.value = false\n          callState.value = 'connected'\n          URL.revokeObjectURL(audioUrl)\n\n          // æ’­æ”¾ç»“æŸåç»§ç»­å½•éŸ³\n          setTimeout(() => {\n            if (funAudioAvailable.value && callState.value === 'connected') {\n              startRecording()\n            }\n          }, 500)\n        }\n\n        audio.onerror = (event) => {\n          console.error('âŒ éŸ³é¢‘æ’­æ”¾é”™è¯¯:', event)\n          isAIPlaying.value = false\n          callState.value = 'connected'\n          URL.revokeObjectURL(audioUrl)\n        }\n\n        await audio.play()\n      } catch (error) {\n        console.error('âŒ TTS APIè°ƒç”¨å¤±è´¥:', error)\n        isAIPlaying.value = false\n        callState.value = 'connected'\n      }\n    } catch (error) {\n      console.error('âŒ è¯­éŸ³åˆæˆå¤±è´¥:', error)\n      isAIPlaying.value = false\n      callState.value = 'connected'\n    }\n  }\n\n  // å¼€å§‹é€šè¯\n  async function startCall(): Promise<void> {\n    if (!funAudioAvailable.value) {\n      console.log('âš ï¸ æ£€æµ‹åˆ°FunAudioLLMæœåŠ¡ä¸å¯ç”¨ï¼Œå°è¯•é‡æ–°æ£€æŸ¥çŠ¶æ€...')\n      await checkServiceStatus()\n      await new Promise(resolve => setTimeout(resolve, 1000))\n    }\n\n    try {\n      callState.value = 'connecting'\n      console.log('ğŸ¤ å¯åŠ¨FunAudioLLMå½•éŸ³æ¨¡å¼')\n      await initRecording()\n      callState.value = 'connected'\n\n      setTimeout(() => {\n        startRecording()\n      }, 1000)\n\n      messages.value = []\n    } catch (error: any) {\n      console.error('âŒ å¼€å§‹é€šè¯å¤±è´¥:', error)\n      callState.value = 'idle'\n      throw new Error('å¼€å§‹é€šè¯å¤±è´¥ï¼Œè¯·æ£€æŸ¥éº¦å…‹é£æƒé™å¹¶é‡è¯•')\n    }\n  }\n\n  // ç»“æŸé€šè¯\n  function endCall(): void {\n    callState.value = 'idle'\n    isRecording.value = false\n    isAIPlaying.value = false\n    currentTranscript.value = ''\n\n    // åœæ­¢æ™ºèƒ½é™éŸ³æ£€æµ‹\n    stopAudioMonitoring()\n\n    // åœæ­¢å½•éŸ³\n    if (mediaRecorder.value && mediaRecorder.value.state === 'recording') {\n      mediaRecorder.value.stop()\n    }\n    mediaRecorder.value = null\n\n    // åœæ­¢éŸ³é¢‘æµ\n    if (audioStream.value) {\n      audioStream.value.getTracks().forEach(track => track.stop())\n      audioStream.value = null\n    }\n\n    // å…³é—­éŸ³é¢‘ä¸Šä¸‹æ–‡\n    if (audioContext.value) {\n      audioContext.value.close()\n      audioContext.value = null\n    }\n    analyserNode.value = null\n\n    // åœæ­¢å½“å‰æ’­æ”¾çš„éŸ³é¢‘\n    if (currentAudio.value) {\n      currentAudio.value.pause()\n      currentAudio.value = null\n    }\n\n    console.log('ğŸ“ é€šè¯å·²ç»“æŸï¼Œæ‰€æœ‰èµ„æºå·²æ¸…ç†')\n  }\n\n  // åˆ‡æ¢é™éŸ³\n  function toggleMute(): void {\n    isMuted.value = !isMuted.value\n    if (currentAudio.value) {\n      currentAudio.value.pause()\n      isAIPlaying.value = false\n    }\n  }\n\n  // ä¸­æ–­AIè¯´è¯\n  function interruptAI(): void {\n    if (isAIPlaying.value) {\n      if (currentAudio.value) {\n        currentAudio.value.pause()\n      }\n      isAIPlaying.value = false\n      callState.value = 'connected'\n\n      if (funAudioAvailable.value) {\n        setTimeout(() => {\n          startRecording()\n        }, 500)\n      }\n    }\n  }\n\n  // æ¸…é™¤å¯¹è¯å†å²\n  async function clearHistory(): Promise<void> {\n    try {\n      const success = await clearConversationHistory(sessionId.value)\n      if (success) {\n        messages.value = []\n        conversationRounds.value = 0\n        console.log('âœ… å¯¹è¯å†å²å·²æ¸…é™¤')\n      } else {\n        console.error('âŒ æ¸…é™¤å¯¹è¯å†å²å¤±è´¥')\n      }\n    } catch (error) {\n      console.error('âŒ æ¸…é™¤å¯¹è¯å†å²é”™è¯¯:', error)\n    }\n  }\n\n  // é‡æ–°å¼€å§‹ä¼šè¯\n  function restartSession(): void {\n    sessionId.value = `voice-chat-${Date.now()}`\n    messages.value = []\n    conversationRounds.value = 0\n    console.log('ğŸ”„ ä¼šè¯å·²é‡æ–°å¼€å§‹')\n  }\n\n  // è·å–çŠ¶æ€æ˜¾ç¤ºæ–‡æœ¬\n  function getStatusText(): string {\n    switch (callState.value) {\n      case 'idle':\n        return 'æœªè¿æ¥'\n      case 'connecting':\n        return 'æ­£åœ¨è¿æ¥...'\n      case 'connected':\n        return 'å·²è¿æ¥'\n      case 'listening':\n        return 'æ­£åœ¨å¬æ‚¨è¯´è¯...'\n      case 'speaking':\n        return 'AIæ­£åœ¨å›å¤...'\n      case 'processing':\n        return 'æ­£åœ¨å¤„ç†...'\n      default:\n        return 'æœªçŸ¥çŠ¶æ€'\n    }\n  }\n\n  // é…ç½®æ™ºèƒ½é™éŸ³æ£€æµ‹å‚æ•°\n  function configureSilenceDetection(config: {\n    threshold?: number\n    timeout?: number\n    minRecordingTime?: number\n    maxRecordingTime?: number\n  }): void {\n    if (config.threshold !== undefined) {\n      silenceThreshold.value = Math.max(0, Math.min(255, config.threshold))\n    }\n    if (config.timeout !== undefined) {\n      silenceTimeout.value = Math.max(500, config.timeout)\n    }\n    if (config.minRecordingTime !== undefined) {\n      minRecordingTime.value = Math.max(500, config.minRecordingTime)\n    }\n    if (config.maxRecordingTime !== undefined) {\n      maxRecordingTime.value = Math.max(5000, config.maxRecordingTime)\n    }\n    \n    console.log('ğŸ”§ æ™ºèƒ½é™éŸ³æ£€æµ‹é…ç½®å·²æ›´æ–°:', {\n      threshold: silenceThreshold.value,\n      timeout: silenceTimeout.value,\n      minRecordingTime: minRecordingTime.value,\n      maxRecordingTime: maxRecordingTime.value\n    })\n  }\n\n  return {\n    // çŠ¶æ€\n    messages,\n    callState,\n    isRecording,\n    isAIPlaying,\n    isMuted,\n    sessionId,\n    conversationRounds,\n    currentTranscript,\n    funAudioAvailable,\n    speechRecognitionAvailable,\n    silenceDetectionActive,\n    \n    // æ™ºèƒ½é™éŸ³æ£€æµ‹é…ç½®\n    silenceThreshold,\n    silenceTimeout,\n    minRecordingTime,\n    maxRecordingTime,\n    \n    // è®¡ç®—å±æ€§\n    hasMessages,\n    isConnected,\n    canStartCall,\n    \n    // æ–¹æ³•\n    addMessage,\n    checkServiceStatus,\n    startCall,\n    endCall,\n    startRecording,\n    stopRecording,\n    toggleMute,\n    interruptAI,\n    clearHistory,\n    restartSession,\n    getStatusText,\n    configureSilenceDetection\n  }\n}) "],"names":["VolumeX","createLucideIcon","useVoiceStore","defineStore","messages","ref","callState","isRecording","isAIPlaying","isMuted","sessionId","conversationRounds","currentTranscript","funAudioAvailable","speechRecognitionAvailable","audioStream","audioContext","currentAudio","analyserNode","mediaRecorder","silenceThreshold","silenceTimeout","minRecordingTime","maxRecordingTime","lastSoundTime","recordingStartTime","silenceDetectionActive","hasMessages","computed","isConnected","canStartCall","addMessage","message","newMessage","generateId","startAudioMonitoring","bufferLength","dataArray","checkAudioLevel","sum","i","averageVolume","currentTime","recordingDuration","silenceDuration","stopRecording","stopAudioMonitoring","checkServiceStatus","checkFunAudioStatus","error","initRecording","stream","source","startRecording","audioChunks","event","audioBlob","handleUserSpeech","transcript","userMessage","aiResponse","result","sendVoiceMessage","endCall","aiMessage","speakText","text","cleanedText","cleanTextForSpeech","audioBuffer","synthesizeSpeech","audioUrl","audio","startCall","resolve","track","toggleMute","interruptAI","clearHistory","clearConversationHistory","restartSession","getStatusText","configureSilenceDetection","config"],"mappings":"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","x_google_ignoreList":[0]}